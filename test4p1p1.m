% code for the tests in Subsection 4.1.1
% code used to generate data for Fig. 1, recorded in fig1_code.m
% table 1 generated by modifying code to change the point distribution by
% changing "distro" variable
% variable q also needs to be changed to match paper data
%       - q=7/3 and 10/4 for Fig. 1, q=3 for Table 1
% The number of points (Nt) must be changed to produce values in Fig. 1
% and Table 1


% LaTex for plots
set(groot,'defaulttextinterpreter','latex'); 
set(groot, 'defaultAxesTickLabelInterpreter','latex');  
set(groot, 'defaultLegendInterpreter','latex')
rng('default');

x2ex = 2.458814705060679;

sur_tol = 1e-14; % tolerance for placing point on surface

% level set and derivatives
phi = @(x,y,z) 0.25./((x-1).^2 + y.^2) + 0.25./((x+1).^2 + y.^2)+ z.^2-...
    1 + 0.1*x.^2 + 0.25*y.^2;
phix = @(x,y,z)  -0.25*2*(x-1)./((x-1).^2 + y.^2).^2 -...
    0.25*2*(x+1)./((x+1).^2 + y.^2).^2 + 0.1*2*x;
phiy = @(x,y,z)  -0.25*2*y./((x-1).^2 + y.^2).^2 -...
    0.25*2*y./((x+1).^2 + y.^2).^2 + 0.25*2*y;
phiz = @(x,y,z)  2*z;

distro = 2; % 1 for regular distribution, 2 for random, 3 for irregular
Nt = 800; % number of surface points
omax = 80; % for seperable: (2*omax + 1)^3 = number of Fourier frequencies
% decay rate of Fourier series: paper uses 7/3, 10/3 for regular
% 3 for random/irregular
q = 3;
T = 12; % shape parameter
ell = 10; % size of bounding box

if distro == 3
    % Irregular Point Distribution (Table 1)
    [xs2, ys2, zs2] = place_b_points(phi, Nt/2, [-1,1], [-4, 4], [-2, 2],...
        sur_tol, 1); % 1 is random

    [xs, ys, zs] = place_b_points(phi, Nt/2, [-5,5], [-4, 4], [-2, 2],...
        sur_tol, 1); % 1 is random
    xs = [xs;xs2]; ys = [ys;ys2]; zs = [zs;zs2];
elseif distro == 1 || distro == 2
    per = 24*(2 - distro) + 1; % 25 when distro==1, 1 when distro==2
    % Regular (Fig. 1) and Random (Table 1) point distributions
    [xs, ys, zs] = place_b_points(phi,Nt, [-5,5], [-4, 4], [-2, 2],...
          sur_tol, per); % parameter per: 25 for regular, 1 for random
else
    "Choose a point distribution: 1 (Regular), 2 (Random), 3 (Irregular)"
end

%% Figure 2
scatter3(xs, ys, zs,10, 'filled', 'k');axis('equal')
title("Random Point Distribution");
view(-45,60)
xlabel('$x$'); ylabel('$y$'); zlabel('$z$');
%% Meshfree method

% normal vectors
[nx, ny, nz] = nml(xs, ys, zs, phix, phiy, phiz); 

"Starting Matrix Formation"

w = (-omax:omax)'*2*pi/ell; % omega_n

d = 1./(exp(q*sqrt(2*pi/T)) + exp(q*sqrt(abs(w)))); % d_n^(-1/2)

n1 = ones(length(nx), 1);

xV = d'.*exp(1i*w'.*xs); % Fourier series matrices in each dimension
yV = d'.*exp(1i*w'.*ys);
zV = d'.*exp(1i*w'.*zs);

% form 4D array E to hold initial Fourier series data and use with helper row-wise
% Kronecker product functions
% These 4D arrays are to store V matrices of the form V1.V2.V3 + V4.V5.V6,
% where "." indicates a row-wise Kronecker product
% the corresponding 4D array A would be formatted as A(1,1,::) = V1, 
% A(1,2,:,:) = V2, A(1,3,:,:) = V3, A(2,1,:,:) = V4, A(2,2,:,:) = V5, 
% A(2,3,:,:) = V6
% E in this case is just the matrix to evaluate a Fourier series: xV.yV.zV
[m, n] = size(xV);
E = zeros([1,3, m, n]);
E(1, 1, :, :) = xV;
E(1, 2, :, :) = yV;
E(1, 3, :, :) = zV;

% compute the Laplacian matrix for the Fourier series in the 4D format
L = [derr(E, n1, w, 1); 
       derr(E, n1, w, 2); 
       derr(E, n1, w, 3);];

% First normal derivative
N = [der(E, nx, w, 1);
       der(E, ny, w, 2);
       der(E, nz, w, 3)];

% Second normal derivative
N2 = [der(N, nx, w, 1);
      der(N, ny, w, 2);
      der(N, nz, w, 3)];


LB = [L; -N2]; % Laplacian minus second normal derivative (Laplace-Beltrami
% for a function with normal derivative = 0), in 4D format

'starting tensors'
% computes the block of the Phi matrix for the Laplace-Beltrami operator
% using the identity (A.B)*(A.B)' = (AA').*(BB') to avoid ever working
% directly with all N_omega terms in the Fourier series!
LBLB = tens_mat_sym(LB); 
'first tensor done'
% cross term block for Laplace-Beltrami and normal derivative
LBN = tens_mat(LB, N);
'second tensor done'
NN = tens_mat_sym(N); % normal derivative block
'tensors done'

% functions g and f, with normal derivative = 0
g = [ones(Nt, 1); zeros(Nt, 1)];
f = [xs.^2; zeros(Nt, 1)];

'forming Phi matrix separable'
% Phi matrix, equivalent to Hermite RBF matrix
F = [LBLB LBN;
     LBN' NN];

F = 1/2*(F + F'); % ensure self-adjoint

rd = 1./sqrt(vecnorm(F, 2, 2));

R = sparse(diag(rd)); % re-scale rows/columns to improve stability

Fp = R*F*R';
Fp = 1/2*real(Fp + Fp'); % ensure self-adjoint
beta = R'*(Fp\(R*g)); % compute beta



cmp = (beta'*f)./(beta'*g); % computed average value
abs(cmp-x2ex)/abs(x2ex) % relative error
  

%% Triangulation
% compute the average value using a triangulation

ptCloud = pointCloud([xs ys zs]);
[mesh,~] = pc2surfacemesh(ptCloud,"ball-pivot"); % mesh the point cloud
%mesh = readSurfaceMesh('300k_ref_ref.stl')

area = 0; % store area
verts = mesh.Vertices;
faces = mesh.Faces;
xa = 0; % store function integral
f = @(x) x.^2;
"Integrating"
for j = 1:length(faces(:,1))
    v1 = verts(faces(j,1),:);
    v2 = verts(faces(j,2),:);
    v3 = verts(faces(j,3),:);
    % integral on triangle with linear interpolation is just average
    % vertex value times area
    xi = (f(v1(1)) + f(v2(1))  + f(v3(1)))/3;
    avg = 1;
    % add to function integral and area for each triangle
    xa = xa + xi*norm(cross(v2-v1,v3-v1))/2;
    area = area + avg*norm(cross(v2-v1,v3-v1))/2;
end

abs(xa/area - x2ex)/abs(x2ex) % relative error
%area

%% Point cloud average
abs(sum(xs.^2)/Nt - x2ex)/abs(x2ex) % relative error

function [nx, ny, nz] = nml(x, y, z, phix, phiy, phiz)
% computes normal vectors to surface at points (x, y, z)
% with level set partial derivatives phix, phiy, phiz
    nx = phix(x,y,z); ny = phiy(x,y,z); nz = phiz(x,y,z);
    nm = vecnorm([nx ny nz],2,2);
    nx = nx./nm; ny = ny./nm; nz = nz./nm;
end

function RN = der(R, n, w, dir)
% Given input 4D array R, compute partial derivative weighted by n at each
% point, with Fourier frequencies given by w, and dir = 1, 2, 3 for x, y,
% and z derivatives, respectively
% 
% 4D array description: These 4D arrays are to store V matrices of the 
% form V1.V2.V3 + V4.V5.V6 + ..., where "." indicates a row-wise Kronecker 
% product
% The corresponding 4D array A would be formatted as A(1,1,::) = V1, 
% A(1,2,:,:) = V2, A(1,3,:,:) = V3, A(2,1,:,:) = V4, A(2,2,:,:) = V5, 
% A(2,3,:,:) = V6
    mult(1,1,:,:) = 1i*(n.*w');
    RN = R; % get dimensions correct
    RN(:,dir, :, :) = mult.*R(:,dir, :, :);
end

function RN = derr(R, n, w, dir)
% Given input 4D array R, compute second partial derivative weighted by n 
% at each point, with Fourier frequencies given by w, and dir = 1, 2, 3 
% for xx, yy, and zz derivatives, respectively
    mult(1,1,:,:) = -(n.*w').^2;
    RN = R;
    RN(:,dir, :, :) = mult.*R(:,dir, :, :);
end

function M = tens_mat(L, R);
% computes the block of a Phi matrix given by terms of the form 
% (Xl.Yl.Zl)*(Xr.Yr.Zr)' = (Xl*Xr').*(Yl*Yr').*(Zl*Zr')
% multiple terms of this form are stored in the 4D array format; the first
% index is summed over
% L and R are sums of row-wise Kronecker product matrices stored in the 4D
% array format. The returned M is L*R' computed without ever fully
% computing the row-wise Kronecker product
    M = zeros(size(L, 3), size(R, 3));
    for j = 1:size(L, 1) % sum over first index
        Mw = zeros(size(L, 3), size(R, 3));
        % L(j, :, :, :) represents a matrix of the form Xl.Yl.Zl
        Xl = reshape(L(j, 1, :, :), [size(L, 3), size(L, 4)]);
        Yl = reshape(L(j, 2, :, :), [size(L, 3), size(L, 4)]);
        Zl = reshape(L(j, 3, :, :), [size(L, 3), size(L, 4)]);
        for k = 1:size(R, 1)
            Xr = reshape(R(k, 1, :, :), [size(R, 3), size(R, 4)]);
            Yr = reshape(R(k, 2, :, :), [size(R, 3), size(R, 4)]);
            Zr = reshape(R(k, 3, :, :), [size(R, 3), size(R, 4)]);
            % add (Xl.Yl.Zl)*(Xr.Yr.Zr)' matrix to sum without fully
            % forming row-wise Kronecker product matrices
            % using equivalent expression
            Mw = Mw + (Xl*Xr').*(Yl*Yr').*(Zl*Zr'); 
        end
        M = M + Mw;
    end
end

function M = tens_mat_sym(L);
% equivalent to tens_mat(L, L), exploiting symmetry for efficiency
    R = L;
    M = zeros(size(L, 3), size(R, 3));
    for j = 1:size(L, 1)
        Xl = reshape(L(j, 1, :, :), [size(L, 3), size(L, 4)]);
        Yl = reshape(L(j, 2, :, :), [size(L, 3), size(L, 4)]);
        Zl = reshape(L(j, 3, :, :), [size(L, 3), size(L, 4)]);
        Mw = (Xl*Xl').*(Yl*Yl').*(Zl*Zl');
        for k = (j+1):size(R, 1) % don't need to sum from 1 due to symmetry
            Xr = reshape(R(k, 1, :, :), [size(R, 3), size(R, 4)]);
            Yr = reshape(R(k, 2, :, :), [size(R, 3), size(R, 4)]);
            Zr = reshape(R(k, 3, :, :), [size(R, 3), size(R, 4)]);
            % add double due to symmetry
            Mw  = Mw+ 2*(Xl*Xr').*(Yl*Yr').*(Zl*Zr'); 
        end
        M = M + Mw;
    end
end
